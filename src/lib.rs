#![doc = "Peripheral access API for CH569 microcontrollers (generated using svd2rust v0.37.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.37.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
#![cfg_attr(docsrs, feature(doc_cfg))]
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[doc = r" Interrupt numbers, priority levels, and HART IDs."]
pub mod interrupt;
#[doc = "SYS register"]
pub type Sys = crate::Periph<sys::RegisterBlock, 0x4000_1000>;
impl core::fmt::Debug for Sys {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sys").finish()
    }
}
#[doc = "SYS register"]
pub mod sys;
#[doc = "TMR0 register"]
pub type Tmr0 = crate::Periph<tmr0::RegisterBlock, 0x4000_2000>;
impl core::fmt::Debug for Tmr0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr0").finish()
    }
}
#[doc = "TMR0 register"]
pub mod tmr0;
#[doc = "TMR1 register"]
pub type Tmr1 = crate::Periph<tmr1::RegisterBlock, 0x4000_2400>;
impl core::fmt::Debug for Tmr1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr1").finish()
    }
}
#[doc = "TMR1 register"]
pub mod tmr1;
#[doc = "TMR2 register"]
pub type Tmr2 = crate::Periph<tmr2::RegisterBlock, 0x4000_2800>;
impl core::fmt::Debug for Tmr2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr2").finish()
    }
}
#[doc = "TMR2 register"]
pub mod tmr2;
#[doc = "UART0 register"]
pub type Uart0 = crate::Periph<uart0::RegisterBlock, 0x4000_3000>;
impl core::fmt::Debug for Uart0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart0").finish()
    }
}
#[doc = "UART0 register"]
pub mod uart0;
#[doc = "UART1 register"]
pub type Uart1 = crate::Periph<uart1::RegisterBlock, 0x4000_3400>;
impl core::fmt::Debug for Uart1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart1").finish()
    }
}
#[doc = "UART1 register"]
pub mod uart1;
#[doc = "UART2 register"]
pub type Uart2 = crate::Periph<uart2::RegisterBlock, 0x4000_3800>;
impl core::fmt::Debug for Uart2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart2").finish()
    }
}
#[doc = "UART2 register"]
pub mod uart2;
#[doc = "UART3 register"]
pub type Uart3 = crate::Periph<uart3::RegisterBlock, 0x4000_3c00>;
impl core::fmt::Debug for Uart3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart3").finish()
    }
}
#[doc = "UART3 register"]
pub mod uart3;
#[doc = "SPI0 register"]
pub type Spi0 = crate::Periph<spi0::RegisterBlock, 0x4000_4000>;
impl core::fmt::Debug for Spi0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi0").finish()
    }
}
#[doc = "SPI0 register"]
pub mod spi0;
#[doc = "SPI1 register"]
pub type Spi1 = crate::Periph<spi1::RegisterBlock, 0x4000_4400>;
impl core::fmt::Debug for Spi1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi1").finish()
    }
}
#[doc = "SPI1 register"]
pub mod spi1;
#[doc = "PWMX register"]
pub type Pwmx = crate::Periph<pwmx::RegisterBlock, 0x4000_5000>;
impl core::fmt::Debug for Pwmx {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwmx").finish()
    }
}
#[doc = "PWMX register"]
pub mod pwmx;
#[doc = "HSPI register"]
pub type Hspi = crate::Periph<hspi::RegisterBlock, 0x4000_6000>;
impl core::fmt::Debug for Hspi {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Hspi").finish()
    }
}
#[doc = "HSPI register"]
pub mod hspi;
#[doc = "ECDC register"]
pub type Ecdc = crate::Periph<ecdc::RegisterBlock, 0x4000_7000>;
impl core::fmt::Debug for Ecdc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ecdc").finish()
    }
}
#[doc = "ECDC register"]
pub mod ecdc;
#[doc = "USBHS register"]
pub type Usbhs = crate::Periph<usbhs::RegisterBlock, 0x4000_9000>;
impl core::fmt::Debug for Usbhs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usbhs").finish()
    }
}
#[doc = "USBHS register"]
pub mod usbhs;
#[doc = "DVP register"]
pub type Dvp = crate::Periph<dvp::RegisterBlock, 0x4000_e000>;
impl core::fmt::Debug for Dvp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dvp").finish()
    }
}
#[doc = "DVP register"]
pub mod dvp;
#[doc = "Program Fast Interrupt Controller"]
pub type Pfic = crate::Periph<pfic::RegisterBlock, 0xe000_e000>;
impl core::fmt::Debug for Pfic {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pfic").finish()
    }
}
#[doc = "Program Fast Interrupt Controller"]
pub mod pfic;
#[doc = "Systick register"]
pub type Systick = crate::Periph<systick::RegisterBlock, 0xe000_f000>;
impl core::fmt::Debug for Systick {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Systick").finish()
    }
}
#[doc = "Systick register"]
pub mod systick;
#[doc = "EMMC register"]
pub type Emmc = crate::Periph<emmc::RegisterBlock, 0x4000_a000>;
impl core::fmt::Debug for Emmc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Emmc").finish()
    }
}
#[doc = "EMMC register"]
pub mod emmc;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "SYS"]
    pub sys: Sys,
    #[doc = "TMR0"]
    pub tmr0: Tmr0,
    #[doc = "TMR1"]
    pub tmr1: Tmr1,
    #[doc = "TMR2"]
    pub tmr2: Tmr2,
    #[doc = "UART0"]
    pub uart0: Uart0,
    #[doc = "UART1"]
    pub uart1: Uart1,
    #[doc = "UART2"]
    pub uart2: Uart2,
    #[doc = "UART3"]
    pub uart3: Uart3,
    #[doc = "SPI0"]
    pub spi0: Spi0,
    #[doc = "SPI1"]
    pub spi1: Spi1,
    #[doc = "PWMX"]
    pub pwmx: Pwmx,
    #[doc = "HSPI"]
    pub hspi: Hspi,
    #[doc = "ECDC"]
    pub ecdc: Ecdc,
    #[doc = "USBHS"]
    pub usbhs: Usbhs,
    #[doc = "DVP"]
    pub dvp: Dvp,
    #[doc = "PFIC"]
    pub pfic: Pfic,
    #[doc = "Systick"]
    pub systick: Systick,
    #[doc = "EMMC"]
    pub emmc: Emmc,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            sys: Sys::steal(),
            tmr0: Tmr0::steal(),
            tmr1: Tmr1::steal(),
            tmr2: Tmr2::steal(),
            uart0: Uart0::steal(),
            uart1: Uart1::steal(),
            uart2: Uart2::steal(),
            uart3: Uart3::steal(),
            spi0: Spi0::steal(),
            spi1: Spi1::steal(),
            pwmx: Pwmx::steal(),
            hspi: Hspi::steal(),
            ecdc: Ecdc::steal(),
            usbhs: Usbhs::steal(),
            dvp: Dvp::steal(),
            pfic: Pfic::steal(),
            systick: Systick::steal(),
            emmc: Emmc::steal(),
        }
    }
}
